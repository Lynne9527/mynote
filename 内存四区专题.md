## 一、内存四区专题

### 1.数据类型的本质

- #### 为创建变量的模子。固定内存大小块的别名(本质)

- #### 编译器预算对象（变量）分配的内存空间大小

  

### 2.学好数组数据类型的三大难点

#### <1> 定义一个数组类型

#### <2> 数组指针

#### <3> 数组类型和数组指针类型的关系

```c
//&b :代表是整个数组的地址
int main(int argc,char** argv)
{
    int a;
    int b[10];//告诉c编辑器分配10*4=40个大小内存
    printf("b=%d\n",b);  			1244972
    printf("b+1=%d\n",b+1);			1244976
    printf("&b=%d\n",&b);			1244972
    printf("&b+1=%d\n",&b+1);		1245012
       
    printf("sizeof(b):%d\n",sizeof(b));//40
    printf("sizeof(a):%d\n",sizeof(a));//4
    return 0;
}
```

### 3.数据类型别名

```c
struct teacher1
{
    char name[64];
    int age;
}teacher1;

typedef struct teacher2
{
    char name[64];
    int age;
}teacher2;

int main()
{
    teacher1 t1; 		//false
    struct teacher1 t1; //true
    teacher2 t2; 		//true
}

```

### 4.数据类型的封装

#### <1> void    ：无类型

#### <2> void * ：可以指向任何类型的数据

#### <3> void   修饰函数返回值和参数，仅表示无

#### <4> void   指针的意义

- ##### c语言规定只有相同类型的指针才可以相互赋值

- ##### void* 指针作为左值用于“接收”任意类型的指针

- ##### void* 指针作为右值赋值给其它指针时需要强制类型转换

- ##### 不存在void类型的变量，c语言没有定义void究竟是多大内存的别名

```c

int  *p1 = NULL;
char *p2 = (char *)malloc(sizeof(char)*20);

```

### 5.变量

#### <1> 变量概念：可读可写的内存对象

#### <2> 常量概念：初始化后不可修改的对象

#### <3> 变量本质：

- ##### 对内存可读可写（一个门牌号编号）

- ##### 通过变量往内存里写数据，不是向变量里读写

- ##### 是向变量所代表的内存空间中写数据

#### <4> 修改变量的方法：

- ##### 直接修改法

- ##### 间接修改法：内存有地址编号，通过地址编号也可以修改内存

### 6.程序内存四区模型

![1557815528885](assets/1557815528885.png)

### 7.各区元素分析

| 栈区（stack）--- 存放函数形参，局部变量的值，由编译器自动分配与释放 |
| ------------------------------------------------------------ |
| **堆区（heap） --- 动态内存申请与释放（一般由程序员操作）若程序员未释放，待程序结束可能由系统回收** |
| **全局区（静态区）---全局变量和静态变量的存储时放在一块的，初始化的全局与静态变量放在同一区域** |
| **全局区（静态区）---未初始的全局与静态变量放在相邻的另一块。该区域在程序结束后由操作系统释放** |
| **常量专属区 --- 存放字符串常量和其他常量，程序结束后系统释放** |
| **程序代码区 --- 存放函数体的二进制代码**                    |

### 8.指针指向谁，就把谁的地址赋给指针

### 9.指针变量和它所指向的内存空间变量是两个不同概念

![1557819219923](assets/1557819219923.png)

### 10.局部变量是不能把内存的块儿返回过来的

### 11.理解指针的关键是内存，没有内存，哪来的指针，没有内存块，哪里来的内存首地址，没有内存首地址，哪里来的指针

### 12.栈的开口有上有下（看是release还是debug版本）一般情况下，操作系统提供的栈开口都是向下的

### 13.不管栈开口向上还是向下，buff的内存地址buff+1永远向上

![1557826724934](assets/155782672488.png)

### 14.函数调用模型变量传递分析

![1557890579074](assets/155789057574.png)

### 